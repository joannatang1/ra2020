// Generated by CoffeeScript 1.10.0
var arrmax, arrmin, deg2rad, gaborgen, meshgrid, pi, rescale, rescale_core;


gaborgen = function(tilt, sf, contrast, reso, sc) {
  var a, aspectratio, b, gab_x, gab_y, gridArray, i, j, m_filt, m_gabor, m_img, m_img_background, m_R, m_G, m_B, multConst, phase, preSinWave, ref, reso, sc, sf_max, sf_min, sinWave, tilt_max, tilt_min, varScale, x, x_centered, x_factor, y, y_centered, y_factor;
  //if ((tilt > 100 || tilt < 1) || (sf > 100 || sf < 1)) {
  //  console.log("ERROR: gaborgen arguenment input out of bounds");
  //}
  if (contrast === undefined) {
	  contrast = 1;
  }
  if (reso === undefined) {
	  reso = 400;
  }
  phase = 0;
  if (sc === undefined) {
	  sc = 50.0;
  }
  var background_contrast = 0.5;
  //contrast = 1.0;
  aspectratio = 1.0;
  tilt_min = 0;
  tilt_max = 90;
  sf_min = .01;
  sf_max = .1;
  //tilt = rescale_core(tilt, tilt_min, tilt_max, 1, 100);
  sf = rescale_core(sf, sf_min, sf_max, 1, 100);
  x = reso / 2;
  y = reso / 2;
  a = numeric.cos([deg2rad(tilt)]) * sf * 360;
  b = numeric.sin([deg2rad(tilt)]) * sf * 360;
  multConst = 1; //1 / (numeric.sqrt([2 * pi]) * sc);
  varScale = 2 * numeric.pow([sc], 2);
  gridArray = numeric.linspace(0, reso);
  ref = meshgrid(gridArray), gab_x = ref[0], gab_y = ref[1];
  x_centered = numeric.sub(gab_x, x);
  y_centered = numeric.sub(gab_y, y);
  x_factor = numeric.mul(numeric.pow(x_centered, 2), -1);
  y_factor = numeric.mul(numeric.pow(y_centered, 2), -1);
  preSinWave = numeric.add(numeric.add(numeric.mul(a, x_centered), numeric.mul(b, y_centered)), phase);
  preSinWave = numeric.div(numeric.mul(preSinWave, pi), 180);
  sinWave = numeric.sin(preSinWave);
  
  // our spatial filter
  m_filt = numeric.exp(numeric.add(numeric.div(x_factor, varScale), numeric.div(y_factor, varScale)));
  // our baseline gabor
  m_gabor = numeric.transpose(numeric.mul(m_filt, numeric.mul(contrast, sinWave)));
  // Move to 0-2 and re-scale to 255
  m_scaled_gabor = numeric.mul(numeric.add(1.0, m_gabor), 255/2)
  // Combine to one matrix
  m_img = [m_scaled_gabor, m_scaled_gabor, m_scaled_gabor];
  //Merge color channels for image
  return numeric.imageURL(m_img)
};




gaborgen_hsl = function(tilt, sf, hue, sat, contrast, reso, sc) {
  var a, aspectratio, b, gab_x, gab_y, gridArray, i, j, m_filt, m_gabor, m_img, m_img_background, m_R, m_G, m_B, multConst, phase, preSinWave, ref, reso, sc, sf_max, sf_min, sinWave, tilt_max, tilt_min, varScale, x, x_centered, x_factor, y, y_centered, y_factor;
  
  //if ((tilt > 100 || tilt < 1) || (sf > 100 || sf < 1)) {
  //  console.log("ERROR: gaborgen arguenment input out of bounds");
  //}
  if (reso === undefined) {
	  reso = 400;
  }
  phase = 0;
  if (sc === undefined) {
	  sc = 50.0;
  }
  aspectratio = 1.0;
  
  // Rescale our spatial frequency variable
  sf_min = .01;
  sf_max = .1;
  sf = rescale_core(sf, sf_min, sf_max, 1, 100);
  
  // Define our grid for calculating the gabor
  x = reso / 2;
  y = reso / 2;
  a = numeric.cos([deg2rad(tilt)]) * sf * 360;
  b = numeric.sin([deg2rad(tilt)]) * sf * 360;
  multConst = 1; //1 / (numeric.sqrt([2 * pi]) * sc);
  varScale = 2 * numeric.pow([sc], 2);
  gridArray = numeric.linspace(0, reso);
  ref = meshgrid(gridArray), gab_x = ref[0], gab_y = ref[1];
  x_centered = numeric.sub(gab_x, x);
  y_centered = numeric.sub(gab_y, y);
  x_factor = numeric.mul(numeric.pow(x_centered, 2), -1);
  y_factor = numeric.mul(numeric.pow(y_centered, 2), -1);
  // convert to sine wave
  preSinWave = numeric.add(numeric.add(numeric.mul(a, x_centered), numeric.mul(b, y_centered)), phase);
  preSinWave = numeric.div(numeric.mul(preSinWave, pi), 180);
  sinWave = numeric.sin(preSinWave);
  
  // our spatial filter (2D Gaussian)
  m_filt = numeric.exp(numeric.add(numeric.div(x_factor, varScale), numeric.div(y_factor, varScale)));
  
  // combine them to create our baseline gabor -- this will be our light variable
  m_gabor = numeric.transpose(numeric.mul(contrast, numeric.mul(m_filt, sinWave)));
  m_gabor = numeric.mul(0.5, numeric.add(1.0, m_gabor));
  
  // create our saturation matrix
  m_sat = numeric.mul(sat, m_filt);
  
  // our hue matrix is all the same as our hue
  m_hue = numeric.rep([reso+1, reso+1], hue);
  
  // Combine to one matrix
  m_img = [m_hue, m_sat, m_gabor];
  // Convert to RGB colors
  scaled_m_img = hsl2rgb(m_img);
  //Return color image
  return numeric.imageURL(scaled_m_img);
};




pi = 3.1416;

deg2rad = function(degrees) {
  return (degrees * pi) / 180;
};

arrmax = numeric.mapreduce('if(xi > accum) accum=xi;', '-Infinity');

arrmin = numeric.mapreduce('if(xi < accum) accum=xi;', 'Infinity');

meshgrid = function(value) {
  var i, m, value_length;
  m = [];
  value_length = value.length;
  i = 0;
  while (i < value_length) {
    m.push(value);
    i += 1;
  }
  return [m, numeric.transpose(m)];
};

rescale_core = function(y, a, b, m, M) {
  if (M - m < .0000001) {
    y;
  }
  return numeric.add(numeric.mul(b - a, numeric.div(numeric.sub(y, m), M - m)), a);
};

rescale = function(y, a, b) {
  return rescale_core(y, a, b, arrmin(y), arrmax(y));
};

hsl2rgb = function(hsl_img) {
  var t1, t2, r, g, b;
  var hue = hsl_img[0];
  var sat = hsl_img[1];
  var light = hsl_img[2];
  var reso = hue.length; 
  
  // create out hue and t1, t2 matrices
  //hue = hue / 60;
  hue = numeric.div(hue, 60);
  //if ( light <= 0.5 ) {
  //  t2 = light * (sat + 1);
  //} else {
  //  t2 = light + sat - (light * sat);
  //}
  light_filt = numeric.leq(light, 0.5);
  light_times_sat = numeric.mul(light, sat);
  t2 = numeric.add(numeric.mul(light_filt, numeric.add(light_times_sat, light)),
		numeric.mul(numeric.not(light_filt), numeric.add(light, numeric.sub(sat, light_times_sat))));
  //t1 = light * 2 - t2;
  t1 = numeric.sub(numeric.mul(light, 2), t2);

  r = numeric.mul(hueToRgb(t1, t2, numeric.add(hue, 2)), 255);
  g = numeric.mul(hueToRgb(t1, t2, hue), 255);
  b = numeric.mul(hueToRgb(t1, t2, numeric.sub(hue, 2)), 255);
  return [r, g, b];
};

function hueToRgb(t1, t2, hue) {
	//if (hue < 0) hue = hue + 6;
	hue = numeric.addeq(hue, numeric.mul(numeric.lt(hue, 0), 6))
	//hue = numeric.add(numeric.mul(numeric.lt(hue, 0), numeric.add(hue, 6)), numeric.mul(numeric.not(numeric.lt(hue, 0)), hue));
	
	//if (hue >= 6) hue = hue - 6;
	hue = numeric.subeq(hue, numeric.mul(numeric.geq(hue, 6), 6))
	//hue = numeric.add(numeric.mul(numeric.geq(hue, 6), numeric.sub(hue, 6)), numeric.mul(numeric.not(numeric.geq(hue, 6)), hue));
	
	//if (hue < 1) return (t2 - t1) * hue + t1;
	//else if(hue < 3) return t2;
	//else if(hue < 4) return (t2 - t1) * (4 - hue) + t1;
	//else return t1;
	t2_sub_t1 = numeric.sub(t2, t1);
	out = numeric.clone(t1);
	out = numeric.addeq(out, numeric.mul(numeric.lt(hue, 1), numeric.mul(t2_sub_t1, hue)));
	out = numeric.addeq(out, numeric.mul(numeric.and(numeric.geq(hue, 3), numeric.lt(hue, 4)), numeric.mul(t2_sub_t1, numeric.sub(4, hue))));
	hue_geq_1_lt_3_filt = numeric.and(numeric.geq(hue, 1), numeric.lt(hue, 3))
	out = numeric.add(numeric.mul(hue_geq_1_lt_3_filt, t2), numeric.mul(numeric.not(hue_geq_1_lt_3_filt), out))
	
	//out = numeric.add(
	//		numeric.add(numeric.mul(numeric.lt(hue, 1), numeric.add(numeric.mul(t2_sub_t1, hue), t1)),
	//					numeric.mul(numeric.and(numeric.geq(hue, 1), numeric.lt(hue, 3)), t2)),
	//		numeric.add(numeric.mul(numeric.and(numeric.geq(hue, 3), numeric.lt(hue, 4)), numeric.add(numeric.mul(t2_sub_t1, numeric.sub(4, hue)), t1)),
	//					numeric.mul(numeric.geq(hue, 4), t1)));
						
	return out;
};

// convert a single element of the matrix to rgb
function hueToRgb_elem(t1, t2, hue) {
	if (hue < 0) hue = hue + 6;
	if (hue >=6) hue = hue - 6;
	if (hue < 1) return (t2 - t1) * hue + t1;
	else if(hue < 3) return t2;
	else if(hue < 4) return (t2 - t1) * (4 - hue) + t1;
	else return t1;
};
//# sourceMappingURL=gab.js.map